"""
This type stub file was generated by pyright.
"""

"""T2CharString operator specializer and generalizer.

PostScript glyph drawing operations can be expressed in multiple different
ways. For example, as well as the ``lineto`` operator, there is also a
``hlineto`` operator which draws a horizontal line, removing the need to
specify a ``dx`` coordinate, and a ``vlineto`` operator which draws a
vertical line, removing the need to specify a ``dy`` coordinate. As well
as decompiling :class:`fontTools.misc.psCharStrings.T2CharString` objects
into lists of operations, this module allows for conversion between general
and specific forms of the operation.

"""
def stringToProgram(string): # -> list[Unknown]:
    ...

def programToString(program): # -> str:
    ...

def programToCommands(program, getNumRegions=...): # -> list[Unknown]:
    """Takes a T2CharString program list and returns list of commands.
    Each command is a two-tuple of commandname,arg-list.  The commandname might
    be empty string if no commandname shall be emitted (used for glyph width,
    hintmask/cntrmask argument, as well as stray arguments at the end of the
    program (¯\_(ツ)_/¯).
    'getNumRegions' may be None, or a callable object. It must return the
    number of regions. 'getNumRegions' takes a single argument, vsindex. If
    the vsindex argument is None, getNumRegions returns the default number
    of regions for the charstring, else it returns the numRegions for
    the vsindex.
    The Charstring may or may not start with a width value. If the first
    non-blend operator has an odd number of arguments, then the first argument is
    a width, and is popped off. This is complicated with blend operators, as
    there may be more than one before the first hint or moveto operator, and each
    one reduces several arguments to just one list argument. We have to sum the
    number of arguments that are not part of the blend arguments, and all the
    'numBlends' values. We could instead have said that by definition, if there
    is a blend operator, there is no width value, since CFF2 Charstrings don't
    have width values. I discussed this with Behdad, and we are allowing for an
    initial width value in this case because developers may assemble a CFF2
    charstring from CFF Charstrings, which could have width values.
    """
    ...

def commandsToProgram(commands): # -> list[Unknown]:
    """Takes a commands list as returned by programToCommands() and converts
    it back to a T2CharString program list."""
    ...

class _GeneralizerDecombinerCommandsMap:
    @staticmethod
    def rmoveto(args): # -> Generator[tuple[Literal['rmoveto'], Unknown], None, None]:
        ...
    
    @staticmethod
    def hmoveto(args): # -> Generator[tuple[Literal['rmoveto'], list[Unknown | int]], None, None]:
        ...
    
    @staticmethod
    def vmoveto(args): # -> Generator[tuple[Literal['rmoveto'], list[int | Unknown]], None, None]:
        ...
    
    @staticmethod
    def rlineto(args): # -> Generator[tuple[Literal['rlineto'], Unknown], None, None]:
        ...
    
    @staticmethod
    def hlineto(args): # -> Generator[tuple[Literal['rlineto'], list[Unknown | int]], None, None]:
        ...
    
    @staticmethod
    def vlineto(args): # -> Generator[tuple[Literal['rlineto'], list[int | Unknown]], None, None]:
        ...
    
    @staticmethod
    def rrcurveto(args): # -> Generator[tuple[Literal['rrcurveto'], Unknown], None, None]:
        ...
    
    @staticmethod
    def hhcurveto(args): # -> Generator[tuple[Literal['rrcurveto'], list[Unknown | int]], None, None]:
        ...
    
    @staticmethod
    def vvcurveto(args): # -> Generator[tuple[Literal['rrcurveto'], list[Unknown | int]], None, None]:
        ...
    
    @staticmethod
    def hvcurveto(args): # -> Generator[tuple[Literal['rrcurveto'], list[Unknown | int]], None, None]:
        ...
    
    @staticmethod
    def vhcurveto(args): # -> Generator[tuple[Literal['rrcurveto'], list[int | Unknown]], None, None]:
        ...
    
    @staticmethod
    def rcurveline(args): # -> Generator[tuple[Literal['rrcurveto'], Unknown] | tuple[Literal['rlineto'], Unknown], None, None]:
        ...
    
    @staticmethod
    def rlinecurve(args): # -> Generator[tuple[Literal['rlineto'], Unknown] | tuple[Literal['rrcurveto'], Unknown], None, None]:
        ...
    


def generalizeCommands(commands, ignoreErrors=...): # -> list[Unknown]:
    ...

def generalizeProgram(program, getNumRegions=..., **kwargs): # -> list[Unknown]:
    ...

def specializeCommands(commands, ignoreErrors=..., generalizeFirst=..., preserveTopology=..., maxstack=...):
    ...

def specializeProgram(program, getNumRegions=..., **kwargs): # -> list[Unknown]:
    ...

if __name__ == "__main__":
    parser = ...
    options = ...
    getNumRegions = ...
    program = ...
    commands = ...
    program2 = ...
