"""
This type stub file was generated by pyright.
"""

from .DefaultTable import DefaultTable
from enum import IntEnum
from functools import lru_cache
from typing import Iterator, NamedTuple, Optional, Tuple

log = ...
have_uharfbuzz = ...
USE_HARFBUZZ_REPACKER = ...
class OverflowErrorRecord:
    def __init__(self, overflowTuple) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class OTLOffsetOverflowError(Exception):
    def __init__(self, overflowErrorRecord) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class RepackerState(IntEnum):
    PURE_FT = ...
    HB_FT = ...
    FT_FALLBACK = ...


class BaseTTXConverter(DefaultTable):
    """Generic base class for TTX table converters. It functions as an
    adapter between the TTX (ttLib actually) table model and the model
    we use for OpenType tables, which is necessarily subtly different.
    """
    def decompile(self, data, font): # -> None:
        """Create an object from the binary data. Called automatically on access."""
        ...
    
    def compile(self, font): # -> bytes:
        """Compiles the table into binary. Called automatically on save."""
        ...
    
    def tryPackingHarfbuzz(self, writer, hb_first_error_logged):
        ...
    
    def tryPackingFontTools(self, writer):
        ...
    
    def tryResolveOverflow(self, font, e, lastOverflowRecord): # -> Literal[0, True, 1]:
        ...
    
    def toXML(self, writer, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    def ensureDecompiled(self, recurse=...): # -> None:
        ...
    


class OTTableReader:
    """Helper class to retrieve data from an OpenType table."""
    __slots__ = ...
    def __init__(self, data, localState=..., offset=..., tableTag=...) -> None:
        ...
    
    def advance(self, count): # -> None:
        ...
    
    def seek(self, pos): # -> None:
        ...
    
    def copy(self): # -> OTTableReader:
        ...
    
    def getSubReader(self, offset): # -> OTTableReader:
        ...
    
    def readValue(self, typecode, staticSize): # -> Any:
        ...
    
    def readArray(self, typecode, staticSize, count): # -> list[int]:
        ...
    
    def readInt8(self): # -> Any:
        ...
    
    def readInt8Array(self, count): # -> list[int]:
        ...
    
    def readShort(self): # -> Any:
        ...
    
    def readShortArray(self, count): # -> list[int]:
        ...
    
    def readLong(self): # -> Any:
        ...
    
    def readLongArray(self, count): # -> list[int]:
        ...
    
    def readUInt8(self): # -> Any:
        ...
    
    def readUInt8Array(self, count): # -> list[int]:
        ...
    
    def readUShort(self): # -> Any:
        ...
    
    def readUShortArray(self, count): # -> list[int]:
        ...
    
    def readULong(self): # -> Any:
        ...
    
    def readULongArray(self, count): # -> list[int]:
        ...
    
    def readUInt24(self): # -> Any:
        ...
    
    def readUInt24Array(self, count): # -> list[Any]:
        ...
    
    def readTag(self): # -> Tag:
        ...
    
    def readData(self, count):
        ...
    
    def __setitem__(self, name, value): # -> None:
        ...
    
    def __getitem__(self, name): # -> dict[Unknown, Unknown] | None:
        ...
    
    def __contains__(self, name): # -> bool | dict[Unknown, Unknown] | None:
        ...
    


class OTTableWriter:
    """Helper class to gather and assemble data for OpenType tables."""
    def __init__(self, localState=..., tableTag=..., offsetSize=...) -> None:
        ...
    
    @property
    def longOffset(self): # -> bool:
        ...
    
    @longOffset.setter
    def longOffset(self, value): # -> None:
        ...
    
    def __setitem__(self, name, value): # -> None:
        ...
    
    def __getitem__(self, name):
        ...
    
    def __delitem__(self, name): # -> None:
        ...
    
    def getDataLength(self): # -> int:
        """Return the length of this table in bytes, without subtables."""
        ...
    
    def getData(self): # -> bytes:
        """Assemble the data for this writer/table, without subtables."""
        ...
    
    def getDataForHarfbuzz(self): # -> bytes:
        """Assemble the data for this writer/table with all offset field set to 0"""
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def getAllDataUsingHarfbuzz(self, tableTag):
        """The Whole table is represented as a Graph.
        Assemble graph data and call Harfbuzz repacker to pack the table.
        Harfbuzz repacker is faster and retain as much sub-table sharing as possible, see also:
        https://github.com/harfbuzz/harfbuzz/blob/main/docs/repacker.md
        The input format for hb.repack() method is explained here:
        https://github.com/harfbuzz/uharfbuzz/blob/main/src/uharfbuzz/_harfbuzz.pyx#L1149
        """
        ...
    
    def getAllData(self, remove_duplicate=...): # -> bytes:
        """Assemble all data, including all subtables."""
        ...
    
    def getSubWriter(self, offsetSize=...): # -> OTTableWriter:
        ...
    
    def writeValue(self, typecode, value): # -> None:
        ...
    
    def writeArray(self, typecode, values): # -> None:
        ...
    
    def writeInt8(self, value): # -> None:
        ...
    
    def writeInt8Array(self, values): # -> None:
        ...
    
    def writeShort(self, value): # -> None:
        ...
    
    def writeShortArray(self, values): # -> None:
        ...
    
    def writeLong(self, value): # -> None:
        ...
    
    def writeLongArray(self, values): # -> None:
        ...
    
    def writeUInt8(self, value): # -> None:
        ...
    
    def writeUInt8Array(self, values): # -> None:
        ...
    
    def writeUShort(self, value): # -> None:
        ...
    
    def writeUShortArray(self, values): # -> None:
        ...
    
    def writeULong(self, value): # -> None:
        ...
    
    def writeULongArray(self, values): # -> None:
        ...
    
    def writeUInt24(self, value): # -> None:
        ...
    
    def writeUInt24Array(self, values): # -> None:
        ...
    
    def writeTag(self, tag): # -> None:
        ...
    
    def writeSubTable(self, subWriter): # -> None:
        ...
    
    def writeCountReference(self, table, name, size=..., value=...): # -> CountReference:
        ...
    
    def writeStruct(self, format, values): # -> None:
        ...
    
    def writeData(self, data): # -> None:
        ...
    
    def getOverflowErrorRecord(self, item): # -> OverflowErrorRecord:
        ...
    


class CountReference:
    """A reference to a Count value, not a count of references."""
    def __init__(self, table, name, size=..., value=...) -> None:
        ...
    
    def setValue(self, value): # -> None:
        ...
    
    def getValue(self):
        ...
    
    def getCountData(self): # -> bytes:
        ...
    


def packUInt8(value): # -> bytes:
    ...

def packUShort(value): # -> bytes:
    ...

def packULong(value): # -> bytes:
    ...

def packUInt24(value): # -> bytes:
    ...

class BaseTable:
    """Generic base class for all OpenType (sub)tables."""
    def __getattr__(self, attr): # -> Any:
        ...
    
    def ensureDecompiled(self, recurse=...): # -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    @classmethod
    def getRecordSize(cls, reader): # -> _NotImplementedType | Literal[0]:
        ...
    
    def getConverters(self): # -> Any:
        ...
    
    def getConverterByName(self, name): # -> Any:
        ...
    
    def populateDefaults(self, propagator=...): # -> None:
        ...
    
    def decompile(self, reader, font): # -> None:
        ...
    
    def compile(self, writer, font):
        ...
    
    def readFormat(self, reader): # -> None:
        ...
    
    def writeFormat(self, writer): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs=..., name=...): # -> None:
        ...
    
    def toXML2(self, xmlWriter, font): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    class SubTableEntry(NamedTuple):
        """See BaseTable.iterSubTables()"""
        name: str
        value: BaseTable
        index: Optional[int] = ...
    
    
    def iterSubTables(self) -> Iterator[SubTableEntry]:
        """Yield (name, value, index) namedtuples for all subtables of current table.

        A sub-table is an instance of BaseTable (or subclass thereof) that is a child
        of self, the current parent table.
        The tuples also contain the attribute name (str) of the of parent table to get
        a subtable, and optionally, for lists of subtables (i.e. attributes associated
        with a converter that has a 'repeat'), an index into the list containing the
        given subtable value.
        This method can be useful to traverse trees of otTables.
        """
        ...
    
    def getVariableAttrs(self): # -> Tuple[str]:
        ...
    


class FormatSwitchingBaseTable(BaseTable):
    """Minor specialization of BaseTable, for tables that have multiple
    formats, eg. CoverageFormat1 vs. CoverageFormat2."""
    @classmethod
    def getRecordSize(cls, reader): # -> _NotImplementedType:
        ...
    
    def getConverters(self): # -> list[Unknown] | Any:
        ...
    
    def getConverterByName(self, name): # -> Any:
        ...
    
    def readFormat(self, reader): # -> None:
        ...
    
    def writeFormat(self, writer): # -> None:
        ...
    
    def toXML(self, xmlWriter, font, attrs=..., name=...): # -> None:
        ...
    
    def getVariableAttrs(self): # -> Tuple[str]:
        ...
    


class UInt8FormatSwitchingBaseTable(FormatSwitchingBaseTable):
    def readFormat(self, reader): # -> None:
        ...
    
    def writeFormat(self, writer): # -> None:
        ...
    


formatSwitchingBaseTables = ...
def getFormatSwitchingBaseTableClass(formatType): # -> Type[FormatSwitchingBaseTable] | Type[UInt8FormatSwitchingBaseTable]:
    ...

@lru_cache()
def getVariableAttrs(cls: BaseTable, fmt: Optional[int] = ...) -> Tuple[str]:
    """Return sequence of variable table field names (can be empty).

    Attributes are deemed "variable" when their otData.py's description contain
    'VarIndexBase + {offset}', e.g. COLRv1 PaintVar* tables.
    """
    ...

valueRecordFormat = ...
valueRecordFormatDict = ...
class ValueRecordFactory:
    """Given a format code, this object convert ValueRecords."""
    def __init__(self, valueFormat) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def readValueRecord(self, reader, font): # -> ValueRecord | None:
        ...
    
    def writeValueRecord(self, writer, font, valueRecord): # -> None:
        ...
    


class ValueRecord:
    def __init__(self, valueFormat=..., src=...) -> None:
        ...
    
    def getFormat(self): # -> Literal[0]:
        ...
    
    def getEffectiveFormat(self): # -> Literal[0]:
        ...
    
    def toXML(self, xmlWriter, font, valueName, attrs=...): # -> None:
        ...
    
    def fromXML(self, name, attrs, content, font): # -> None:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


